<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body, html {
            width: 100%;
            height: 100%;
        }

        .container {
            width: 100%;
            height: 100%;
            border: 1px solid black;
        }

        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas width="1600" height="800">

        </canvas>
    </div>
</body>
<script src="../util.js" type="module"></script>
<script type="module">
    import { drawArrow } from '../util.js'

    let canvas = document.querySelector('canvas');
    let data_lst = [
        {
            value: '1',
            children: [
                {
                    value: '2',
                    children: [
                        {
                            value: '5',
                            style: {
                                min_point_area_width: 500,
                                min_line_area_height: 60,
                                width: 300,
                            }
                        },
                        {
                            value: '6',
                        }
                    ]
                },
                {
                    value: '3',
                    children: [
                        {
                            value: '7',
                        }
                    ]
                },
                {
                    value: '4',
                    children: [
                        {
                            value: '8',
                        },
                        {
                            value: '9',
                        }
                    ]
                }
            ]
        }
    ];

    class AutoWidthTree {
        env = void 0;
        option = {};

        // todo 抽象添加个性化配置
        // todo 先做长宽位置
        constructor(data_lst = [], canvas, option) {
            let default_option = {
                env: window,
                min_area_width: 50,
                global_style: {
                    entirety_style: {
                        x:0,
                        y:0,
                        min_point_area_width: 60,  // 这两个属性可能需要修改，纵向和横向的时候是不一样的。所以命名需要商榷
                        min_line_area_height: 200,  //
                    },
                    point_style: {
                        shape: 'rect',  // rect circle [custom] 甚至可以是canvas 图片或者自定义函数
                        border: {
                            border_width: 0,
                            border_color: 'black',
                        },
                        border_radius: 0,
                        background_color: 'yellow',
                        width: 40,
                        height: 40,
                    },
                    font_style: {
                        font: '12px serif',
                        textAlign: 'end',
                        textBaseline: 'top',
                        direction: 'rtl',
                        fillStyle: 'black',
                    },
                    line_style: {

                    },
                }
            };

            this.option = Object.assign(default_option, option || {});
            this.data_lst = data_lst;
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');

            this._transformData(this.data_lst);
            this._drawTree(this.data_lst[0], 0, 0);
        }

        _transformData(lst) {
            let min_point_area_width = 0;

            for (var obj of lst) {
                if (!obj.style) {
                    obj.style = {};
                }

                let tmp_min_point_area_width = 0;

                if (obj.children) {
                    tmp_min_point_area_width = this._transformData(obj.children);
                }
                else {
                    if (obj.style && obj.style.min_point_area_width) {
                        tmp_min_point_area_width = obj.style.min_point_area_width;
                    }
                    else {
                        tmp_min_point_area_width = this.option.global_style.entirety_style.min_point_area_width;
                    }
                }



                obj.style.min_point_area_width = tmp_min_point_area_width;
                obj.style.width =  obj.style.width || this.option.global_style.point_style.width;
                obj.style.height =  obj.style.height || this.option.global_style.point_style.height;

                if (obj.style.width > obj.style.min_point_area_width) {
                    obj.style.width = obj.style.min_point_area_width;
                }

                min_point_area_width += tmp_min_point_area_width
            }

            return min_point_area_width
        }

        _drawTree(obj, offset_x, offset_y, line_s_pos) {
            obj.style.x = obj.style.min_point_area_width / 2 + offset_x  - obj.style.width / 2;
            obj.style.y = obj.style.height / 2 + offset_y;

            this._drawPoint(obj);
            this._drawFont(obj);

            if (line_s_pos) {
                let e_pos = {
                    x: obj.style.x  + obj.style.width / 2,
                    y: obj.style.y,
                };

                this._drawArrowLine(line_s_pos, e_pos);
            }

            let s_pos = {
                x: obj.style.x + obj.style.width / 2,
                y: obj.style.y + obj.style.height,
            };

            if (obj.children) {
                let min_line_area_height = obj.style.min_line_area_height || this.option.global_style.entirety_style.min_line_area_height;
                let next_offset_y = obj.style.height + min_line_area_height + offset_y;
                let next_offset_x = offset_x;

                for (var i = 0, length = obj.children.length; i < length; i++) {
                    let c_obj = obj.children[i];

                    if (i === 0) {
                        next_offset_x += 0;
                    }
                    else {
                        let last_obj = obj.children[i - 1];
                        next_offset_x += last_obj.style.min_point_area_width;
                    }

                    this._drawTree(c_obj, next_offset_x, next_offset_y, s_pos);
                }
            }
        }

        _drawPoint(obj) {
            this.ctx.beginPath();
            this.ctx.fillStyle = 'yellow';
            this.ctx.fillRect(obj.style.x, obj.style.y, obj.style.width, obj.style.height);
            this.ctx.fill();
            this.ctx.closePath();
        }

        _drawFont(obj) {
            let global_font_style = this.option.global_style.font_style;
            let keys = Object.keys(global_font_style);

            for (var key of keys) {
                this.ctx[key] = global_font_style[key];
            }

            if (obj.font_style) {
                let keys = Object.keys(obj.font_style);

                for (var key of keys) {
                    this.ctx[key] = obj.font_style[key];
                }
            }

            this.ctx.fillText(obj.value, obj.style.x + obj.style.width / 2 - 4, obj.style.y + obj.style.height / 2 - 4);
        }

        _drawLine(obj) {
            this.ctx.beginPath();
            this.ctx.fillStyle = 'black';
            this.ctx.moveTo(obj.s_pos.x, obj.s_pos.y);
            this.ctx.lineTo(obj.e_pos.x, obj.e_pos.y);
            this.ctx.closePath();
        }

        _drawArrowLine(s_pos, e_pos) {
            drawArrow(this.ctx, s_pos, e_pos)
        }
    }

    let auto_width_tree = new AutoWidthTree(data_lst, canvas);
</script>
</html>
